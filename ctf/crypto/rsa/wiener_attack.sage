#https://doc.sagemath.org/html/en/reference/diophantine_approximation/sage/rings/continued_fraction.html
from Crypto.Util.number import *

def wiener_attack(e, n):
    frac = continued_fraction(e/n)
    for i in range(len(frac)):
        k = frac.numerator(i)
        d = frac.denominator(i)
        
        #check if d is actually the key
        if k!=0 and (e*d-1)%k == 0:
            phi = (e*d-1)//k
            s = n - phi + 1
            # check if the equation x^2 - s*x + n = 0
            # has integer roots
            discr = s*s - 4*n
            if discr>=0 and discr.is_square():
                p = (s + sqrt(discr)) / 2
                q = (s - sqrt(discr)) / 2
                if p * q == n:
                    return (p, q, d)
    print("failed to found solution")
    exit()
    
n=56661243519426563299920058134092862370737397949947210394843021856477420959615132553610830104961645574615005956183703191006421508461009698780382360943562001485153455401650697532951591191737164547520951628336941289873198979641173541232117518791706826699650307105202062429672725308809988269372149027026719779368169
e=36269788044703267426177340992826172140174404390577736281478891381612294207666891529019937732720246602062358244751177942289155662197410594434293004130952671354973700999803850153697545606312859272554835232089533366743867361181786472126124169787094837977468259794816050397735724313560434944684790818009385459207329
c=137954301101369152742229874240507191901061563449586247819350394387527789763579249250710679911626270895090455502283455665178389917777053863730286065809459077858674885530015624798882224173066151402222862023045940035652321621761390317038440821354117827990307003831352154618952447402389360183594248381165728338233
print n.nbits()
(p, q, d) = wiener_attack(e, n)
print p, q, d

d = e.inverse_mod((p-1)*(q-1))
print d

m = power_mod(c, d, n)
print long_to_bytes(m)